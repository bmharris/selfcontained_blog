<!DOCTYPE html><html lang="en"><head><title>Javascript widget approaches: Singleton vs Prototype</title><meta name="keywords" content="javascript,yui"><meta name="author" content="Brad Harris"><meta name="robots" content="index,follow"><meta name="viewport" content="width=device-width,initial-scale=0.5"><link href="/css/blog.css" rel="stylesheet"><link rel="alternate" type="application/rss+xml" title="selfcontained Â» rss" href="http://www.selfcontained.us/feed/rss.xml"></head><body><div id="main"><header><h1><a href="/">selfcontained</a><small>[web development]</small></h1></header><div id="content-container"><aside class="sidebar"><div class="about"><img src="/images/bradharris.gif" width="100" height="100" align="left"><p>	My name is Brad Harris and I'm an engineer @ Yahoo!
	I love architecting software and developing simple and elegant solutions to complex problems. I
	've worked for companies on large enterprise projects, as well as smaller projects, and fine satisfaction across the board.
	I enjoy learning and applying new principles and patterns to my work.
</p></div><div class="recent-articles"><h3>recent articles</h3><ul><li><a href="/2013/09/14/flipflop-0.1.0-configurable-urls">flipflop 0.1.0 - configurable urls</a><div class="date">Saturday September 14, 2013</div></li><li><a href="/2012/09/20/using-express-with-broadway">using express with broadway</a><div class="date">Thursday September 20, 2012</div></li><li><a href="/2012/09/18/decoupling-your-node-js-application-with-broadway">decoupling your node.js application with broadway</a><div class="date">Tuesday September 18, 2012</div></li><li><a href="/2012/09/01/hello-fabric">hello fabric</a><div class="date">Saturday September 1, 2012</div></li><li><a href="/2012/05/08/node-js-circular-dependencies">node.js and circular dependencies</a><div class="date">Tuesday May 8, 2012</div></li><li><a href="/2012/04/27/backup-iphoto-with-google-drive">google.drive.backup(iphoto.library)</a><div class="date">Friday April 27, 2012</div></li><li><a href="/2012/04/14/makdown-powered-blogs">markdown powered blogs</a><div class="date">Saturday April 14, 2012</div></li><li><a href="/2012/04/04/node-js-clusters">node.js clusters</a><div class="date">Wednesday April 4, 2012</div></li><li><a href="/2011/07/08/markdown-me">markdown.me</a><div class="date">Friday July 8, 2011</div></li><li><a href="/2011/05/28/phpunit-mocks-and-closures">PHPUnit, Mocks and Closures</a><div class="date">Saturday May 28, 2011</div></li><li><a href="/2011/04/20/php-and-an-abstract-singleton">PHP and an abstract Singleton</a><div class="date">Wednesday April 20, 2011</div></li><li><a href="/2011/04/20/review-yahoo-user-interface-library-2-x-cookbook">Review: Yahoo! User Interface Library 2.x Cookbook</a><div class="date">Wednesday April 20, 2011</div></li><li><a href="/2011/02/28/awaiting-yahoo-user-interface-library-2-x-cookbook">Awaiting Yahoo! User Interface Library 2.x Cookbook</a><div class="date">Monday February 28, 2011</div></li><li><a href="/2011/01/23/latest-endeavor-whoopdwhoop-com">Latest Endeavor: whoopdwhoop.com</a><div class="date">Sunday January 23, 2011</div></li><li><a href="/2010/11/30/php-coalesce">?: PHP Coalesce</a><div class="date">Tuesday November 30, 2010</div></li><li><a href="/2010/11/19/yui-jquery">YUI =&gt; jQuery?</a><div class="date">Friday November 19, 2010</div></li><li><a href="/2010/10/22/yahoo-new-adventure">Yahoo!  A New Adventure</a><div class="date">Friday October 22, 2010</div></li><li><a href="/2010/09/04/yui-2-8-learning-the-library-book-review">YUI 2.8 Learning the Library book review</a><div class="date">Saturday September 4, 2010</div></li><li><a href="/2010/08/13/yui-2-8-learning-the-library-free-chapter">&quot;YUI 2.8: Learning the Library&quot; Free Chapter</a><div class="date">Friday August 13, 2010</div></li><li><a href="/2010/05/08/first-iphone-app-lds-gems">First iPhone App - LDS Gems</a><div class="date">Saturday May 8, 2010</div></li><li><a href="/2010/03/30/doctrine-model-hydration">Doctrine Model Hydration</a><div class="date">Tuesday March 30, 2010</div></li><li><a href="/2009/09/16/getting-keycode-values-in-javascript">Getting keycode values in Javascript</a><div class="date">Wednesday September 16, 2009</div></li><li><a href="/2009/01/23/scoping-javascript-closures-in-loops">Scoping Javascript closures in loops</a><div class="date">Friday January 23, 2009</div></li><li><a href="/2009/01/23/browser-autocomplete-and-keyup-events">Browser autocomplete and keyup events</a><div class="date">Friday January 23, 2009</div></li><li><a href="/2009/01/22/followup-on-yui-getfirstdescendantby">Followup on YUI : getFirstDescendantBy()</a><div class="date">Thursday January 22, 2009</div></li></ul></div><div class="links"><h3>links</h3><ul><li><a href="/archive">archive</a></li><li><a href="/feed/rss.xml">feed</a></li></ul></div></aside><section id="content"><article><h2><a href="/2008/12/23/javascript-widget-approaches-singleton-vs-prototype">Javascript widget approaches: Singleton vs Prototype</a></h2><div class="meta"><ul class="tags"><li><a href="/tag/javascript">javascript</a></li><li><a href="/tag/yui">yui</a></li></ul><img src="http://www.gravatar.com/avatar/c20763ec853bb1d2eb3e8a08cc5a28b9?s=30.jpg" width="30" height="30"><div class="date">Tuesday December 23, 2008</div><div class="name">By Brad Harris</div></div><div class="content"><p>Recently I&#39;ve been doing some work setting up some standard javascript widgets for a web application I am working on.  By widget, I&#39;m referring to items such as javascript date pickers, tooltips, autocomplete inputs, etc.  I&#39;m building on top of YUI for this approach, but the principles I&#39;d like to discuss are applicable to any library.  YUI provides a fantastic javascript library, and a collection of widgets right out of the box.  More than likely, as you add them to your application, you&#39;ll want to wrap or extend them in your own javascript implementations to get them functioning as desired.  To accomplish this, I typically have taken one of two approaches, and these are the topics I&#39;d like to cover.  To provide a working example, I&#39;ll use a simple wrapper for a YUI Calendar widget that is linked to a text input, and opens by clicking a calendar icon.

</p>
<p><img src="/images/datepicker.gif" alt="image of a date picker widget">

</p>
<h1>Prototype approach</h1>
<p>This approach basically creates an instance of the javascript widget for each input field, and the javascript widget object utilizes the prototype definition so the internal functions can be defined once in memory.  Below is an example of what a simple DatePicker widget that &quot;wraps&quot; the YUI Calendar widget, would look like:

</p>
<pre><code class="lang-javascript"><span class="keyword">function</span> DatePicker(icon, field) {
    <span class="keyword">this</span>.icon = icon;
    <span class="keyword">this</span>.field = field;
    YAHOO.util.Event.addListener(window, <span class="string">'load'</span>, <span class="keyword">this</span>.initialize, <span class="keyword">this</span>, <span class="keyword">true</span>);
}
DatePicker.prototype = {

    icon : <span class="keyword">null</span>,

    field : <span class="keyword">null</span>,

    calendar : <span class="keyword">null</span>,

    id : <span class="string">'date-calendar'</span>,

    container : <span class="keyword">null</span>,

    initialize : <span class="keyword">function</span>() {
        YAHOO.util.Event.addListener(<span class="keyword">this</span>.icon, <span class="string">'click'</span>, <span class="keyword">this</span>.click, <span class="keyword">this</span>, <span class="keyword">true</span>);
        <span class="keyword">this</span>.renderContainer();
    },

    renderContainer : <span class="keyword">function</span>() {
        <span class="keyword">this</span>.container = document.createElement(<span class="string">'div'</span>);
        <span class="keyword">this</span>.container.style.display = <span class="string">'none'</span>;
        document.body.appendChild(<span class="keyword">this</span>.container);
    },

    click : <span class="keyword">function</span>(e) {
        <span class="keyword">if</span>(<span class="keyword">this</span>.calendar === <span class="keyword">null</span>) {
            <span class="keyword">this</span>.renderCalendar();
        }
        <span class="keyword">this</span>.calendar.show();
        <span class="keyword">this</span>.positionCalendar();
    },

    renderCalendar : <span class="keyword">function</span>() {
        <span class="keyword">this</span>.calendar = <span class="keyword">new</span> YAHOO.widget.Calendar(<span class="keyword">this</span>.field+<span class="string">'-calendar'</span>, <span class="keyword">this</span>.container, { title:<span class="string">'Choose a date:'</span>, close:<span class="keyword">true</span>, navigator: <span class="keyword">true</span> } );
        <span class="keyword">this</span>.calendar.selectEvent.subscribe(<span class="keyword">this</span>.populateDateField, <span class="keyword">this</span>, <span class="keyword">true</span>);
        <span class="keyword">this</span>.calendar.render();
    },

    positionCalendar : <span class="keyword">function</span>() {
        <span class="keyword">var</span> position = YAHOO.util.Dom.getXY(<span class="keyword">this</span>.field);
        position[<span class="number">1</span>] = position[<span class="number">1</span>] + <span class="number">25</span>;
        YAHOO.util.Dom.setXY(<span class="keyword">this</span>.container, position);
    },

    populateDateField : <span class="keyword">function</span>() {
        <span class="keyword">var</span> date = <span class="keyword">this</span>.calendar.getSelectedDates()[<span class="number">0</span>];
        YAHOO.util.Dom.get(<span class="keyword">this</span>.field).value = date.getMonth() + <span class="string">'/'</span> + date.getDate() + <span class="string">'/'</span> + date.getFullYear();
        <span class="keyword">this</span>.calendar.hide();
    },

    hide : <span class="keyword">function</span>() {
        <span class="keyword">if</span>(<span class="keyword">this</span>.calendar !== <span class="keyword">null</span>) {
            <span class="keyword">this</span>.calendar.hide();
        }
    }

};</code></pre>
<p>The html for creating this widget is as simple as follows:

</p>
<pre><code class="lang-html">&lt;script type=<span class="string">"text/javascript"</span>>
    <span class="keyword">new</span> DatePicker(<span class="string">'date-icon'</span>, <span class="string">'date-field'</span>);
&lt;/script>
&lt;label>Date: &lt;/label>
&lt;input type=<span class="string">"text"</span> name=<span class="string">"date-field"</span> id=<span class="string">"date-field"</span> />
&lt;img src=<span class="string">"images/calendar.png"</span> id=<span class="string">"date-icon"</span> /></code></pre>
<p>Some benefits to this approach are that the instance of the widget object has a direct reference to the input id and calendar icon id, and nothing has to be &#39;inspected&#39; at runtime execution of the events.  This leads to some cleaner code on a small level.  It also has some downsides as we&#39;ll discuss below.

</p>
<h1>Singleton approach</h1>
<p>The Singleton approach creates a &#39;singleton&#39; wrapper object that creates <strong>ONE</strong> YUI Calendar widget that is re-used across all input fields.  At runtime, the icon clicked on is used to determine which input field is in use through an extra attribute added to the icon image called &#39;data-field&#39; that contains the id of the input it is linked to.  This code would look as follows:

</p>
<pre><code class="lang-javascript">DatePickerSingleton = {

    calendar : <span class="keyword">null</span>,

    id : <span class="string">'date-calendar'</span>,

    container : <span class="string">'date-calendar-container'</span>,

    activeInput : <span class="keyword">null</span>,

    initialize : <span class="keyword">function</span>() {
        <span class="keyword">var</span> icons = YAHOO.util.Selector.query(<span class="string">'.date-icon'</span>);
        YAHOO.util.Event.addListener(icons, <span class="string">'click'</span>, <span class="keyword">this</span>.click, <span class="keyword">this</span>, <span class="keyword">true</span>);
        <span class="keyword">this</span>.renderContainer();
    },

    renderContainer : <span class="keyword">function</span>() {
        <span class="keyword">var</span> container = document.createElement(<span class="string">'div'</span>);
        container.id = <span class="keyword">this</span>.container;
        container.style.display = <span class="string">'none'</span>;
        document.body.appendChild(container);
    },

    click : <span class="keyword">function</span>(e) {
        <span class="keyword">this</span>.activeInput = common.byEvent(e).getAttribute(<span class="string">'data-field'</span>);
        <span class="keyword">if</span>(<span class="keyword">this</span>.calendar === <span class="keyword">null</span>) {
            <span class="keyword">this</span>.renderCalendar();
        }
        <span class="keyword">this</span>.calendar.show();
        <span class="keyword">this</span>.positionCalendar();
    },

    renderCalendar : <span class="keyword">function</span>() {
        <span class="keyword">this</span>.calendar = <span class="keyword">new</span> YAHOO.widget.Calendar(<span class="keyword">this</span>.id, <span class="keyword">this</span>.container, { title:<span class="string">'Choose a date:'</span>, close:<span class="keyword">true</span>, navigator: <span class="keyword">true</span> } );
        <span class="keyword">this</span>.calendar.selectEvent.subscribe(<span class="keyword">this</span>.populateDateField, <span class="keyword">this</span>, <span class="keyword">true</span>);
        <span class="keyword">this</span>.calendar.render();
    },

    positionCalendar : <span class="keyword">function</span>() {
        <span class="keyword">var</span> position = YAHOO.util.Dom.getXY(YAHOO.util.Dom.get(<span class="keyword">this</span>.activeInput));
        position[<span class="number">1</span>] = position[<span class="number">1</span>] + <span class="number">25</span>;
        YAHOO.util.Dom.setXY(<span class="keyword">this</span>.container, position);
    },

    populateDateField : <span class="keyword">function</span>() {
        <span class="keyword">var</span> date = <span class="keyword">this</span>.calendar.getSelectedDates()[<span class="number">0</span>];
        YAHOO.util.Dom.get(<span class="keyword">this</span>.activeInput).value = date.getMonth() + <span class="string">'/'</span> + date.getDate() + <span class="string">'/'</span> + date.getFullYear();
        <span class="keyword">this</span>.calendar.hide();
    },

    hide : <span class="keyword">function</span>() {
        <span class="keyword">if</span>(<span class="keyword">this</span>.calendar !== <span class="keyword">null</span>) {
            <span class="keyword">this</span>.calendar.hide();
        }
    }

};
YAHOO.util.Event.addListener(window, <span class="string">'load'</span>, DatePickerSingleton.initialize, DatePickerSingleton, <span class="keyword">true</span>);</code></pre>
<p>The html for creating this widget is as simple as follows:

</p>
<pre><code class="lang-html">&lt;div <span class="keyword">class</span>=<span class="string">"code-highlight"</span>>&lt;code>
&lt;label>Date: &lt;/label>
&lt;input type=<span class="string">"text"</span> id=<span class="string">"date_field"</span> />
&lt;img src=<span class="string">"images/calendar.png"</span> <span class="keyword">class</span>=<span class="string">"date-icon"</span> data-field=<span class="string">"date_field"</span> /></code></pre>
<h1>Results</h1>
<p>After testing out each of these approaches using a range from 1 to 1000 inputs on a page, I noticed some interesting side effects.  Both approaches load using almost the same amount of resources.  You might think the Prototype approach would require more memory on page load to create each of the widgets for each input, but in reality, due to the prototype definition, the only additional memory needed for each widget is for the unique element id&#39;s stored as attributes.  Each approach also uses a &#39;lazy loading&#39; approach, that causes the Calendar widget to not be created until the user actually clicks on an icon.  This is where the two approaches begin to differ.

</p>
<p>The Singleton approach consumes a small amount of additional memory on the first click, as it creates the Calendar widget at this time.  For subsequent clicks the memory stays the same, as the objects have already been created, and are just being re-used.  A downside to this approach is that on page load, a javascript css selector query has to be executed to gather all date picker icons to set up click events for them.  This &#39;can&#39; be time consuming with a large number of elements (1000+).

</p>
<p>The Prototype approach will consume additional memory for each new icon that is clicked, as there is a Calendar widget created lazily for each input at the runtime click event of the icon.  From my simple tests, I saw an increase ranging from 51.2 kb to 358.4 kb for each additional widget instantiated (each new icon clicked).  In contrast to the Singleton approach, on page load there is no css selector query to run in order to attach the click events, as the element ids are already in memory from the instantiation of each &#39;wrapper&#39; (DatePicker) object.  This saves the possibly heavy css based query, but adds an initialize function for each input to the page load, which can be time consuming as well.

</p>
<p>Recently I have been using the Singleton approach for creating widgets where it is possible, as I believe it scales better, and avoids the problem of memory increasing as users go about using the application.  This can be accentuated even further when page life cycle is long such as in the case of single page web applications.  I found this little exercise interesting in my own work, and hope it is informative for some other people out there.  I&#39;d love to hear any comments regarding this from everyone out there.

</p>

</div><div class="comments"><div id="disqus_thread"></div><script type='text/javascript'>disqus_identifier='/2008/12/23/javascript-widget-approaches-singleton-vs-prototype';disqus_url='http://selfcontained.us/2008/12/23/javascript-widget-approaches-singleton-vs-prototype';</script><script type="text/javascript">var disqus_shortname = 'selfcontained';
(function() {
 var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
 dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
 (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();

</script><noscript>	Please enable JavaScript to view the
<a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">blog comments powered by<span class="logo-disqus">Disqus</span></a></div></article></section></div><footer>	&copy; 2012 Brad Harris |
	powered by
<a href="https://github.com/selfcontained/flipflop">flipflop</a></footer></div><script type="text/javascript">var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-254292-12']);
_gaq.push(['_trackPageview']);

(function() {
 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script></body></html>